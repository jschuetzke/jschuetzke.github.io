<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://jschuetzke.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jschuetzke.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-02-24T11:20:22+00:00</updated><id>https://jschuetzke.github.io/feed.xml</id><title type="html">blank</title><subtitle>Accelerating the analysis of diffraction or spectroscopy data. </subtitle><entry><title type="html">Simulation of realistic powder X-ray diffraction patterns</title><link href="https://jschuetzke.github.io/blog/2024/realistic-xrd-simulation/" rel="alternate" type="text/html" title="Simulation of realistic powder X-ray diffraction patterns"/><published>2024-02-23T09:05:00+00:00</published><updated>2024-02-23T09:05:00+00:00</updated><id>https://jschuetzke.github.io/blog/2024/realistic-xrd-simulation</id><content type="html" xml:base="https://jschuetzke.github.io/blog/2024/realistic-xrd-simulation/"><![CDATA[<p>This post shows how to utilize the python-powder-diffraction package to simulate realistic powder XRD patterns.</p> <h2 id="powder-xrd-patterns">Powder XRD patterns</h2> <p>X-ray diffraction (XRD) is a popular method to analyze crystalline sampes. In practice, the sample is often ground into a fine powder to analyze the sample from all directions simultaneously without the need to rotate the sample. Thus, the data is recorded as pairs of angles (typically \(2θ\)) and corresponding intensities. These diffraction patterns provide valuable information about the crystal structure, including lattice spacing and symmetry. Furthermore, the pattern contains information regarding the specimen, such as the size of grains in the powder.</p> <p>Depending on the chemical composition and arrangement within the resulting crystal structure, each material exhibits a unique diffraction pattern characterized by specific peak intensities and positions. As a result, the diffraction pattern serves as a distinctive fingerprint that can be used to identify materials present in the recorded data. By comparing experimental diffraction patterns with known reference patterns stored in databases, scientists can accurately determine the composition and structure of the crystalline sample under investigation. Therefore, XRD is widely employed in various domains to rapidly identify known materials and ensure quality control, while also playing a crucial role in research to determine the properties of novel materials.</p> <h3 id="appearance">Appearance</h3> <p>The following figure shows an exemplary XRD pattern that has been acquired from the <a href="https://rruff.info/">RRUFF database</a>. In particular, entry R050031 has been selected, which corresponds to the mineral rutile. This substance with chemical composition TiO<sub>2</sub> and a tetragonal crystal structure has been analyzed using a XRD instrument with a copper anode (wavelength 0.1540562 nm), resulting in the following pattern:</p> <div class="l-page"> <iframe src="/assets/plotly/rutile_R050031.html" frameborder="0" scrolling="no" height="500px" width="100%" style="border: 1px dashed grey;"></iframe> </div> <p>The signal displays multiple peaks (e.g., at positions 27, 36, and 54 degrees \(2θ\)), each exhibiting a broad shape. Additionally, the signal exhibits noise and artifacts, such as the bump observed at the beginning of the measurement, which do not correspond to the characteristic diffraction pattern of the rutile sample. These discrepancies may be attributed to various factors collectively referred to as “background”. The analysis of the acquired diffraction pattern enabled the determination of lattice parameters, as reported: \(a = b = 4.5945; c = 2.9594\).</p> <h3 id="reported-information">Reported Information</h3> <p>While the RRUFF database offers measured XRD patterns for certain minerals, the data extracted from these diffraction patterns is generally stored in a condensed format. Databases like the <a href="https://www.crystallography.net/cod/">COD</a> or the <a href="https://icsd.fiz-karlsruhe.de/">ICSD</a> have thousands of entries, containing comprehensive information on chemical composition and crystal structure arrangement. These databases also offer the option to download the structural information, often in the form of <em>crystallographic information files</em> (<a href="https://www.iucr.org/resources/cif/documentation">CIFs</a>), which allows researchers to utilize the data for subsequent analysis and simulations.</p> <hr/> <h2 id="pattern-simulation">Pattern Simulation</h2> <p>Utilizing the condensed information, calculating the corresponding positions and intensities of diffraction peaks for a given structure becomes a straightforward process. Therefore, this method has been incorporated into numerous software packages, including those designed for the Search/Match procedure and various scientific applications. For the purposes of this post, the implementation provided by <a href="https://pymatgen.org/"><em>pymatgen</em></a> is utilized, though alternative options such as <a href="https://cctbx.github.io/"><em>cctbx</em></a> are also available. An overview of commercial and free-to-use Search/Match software is given <a href="http://www.ccp14.ac.uk/solution/search-match.htm">here</a>.</p> <h3 id="requirements">Requirements</h3> <p>In order to utilize the Python package <em>pymatgen</em>, several prerequisites are required:</p> <ol> <li>A fresh Python environment, e.g., through venv or conda.</li> <li>The installation of pymatgen and required packages through <code class="language-plaintext highlighter-rouge">pip install pymatgen</code>.</li> <li>A CIF of the structure to simulate, here a rutile structure from the COD <a href="http://www.crystallography.net/cod/9015662.html">9015662</a>.</li> </ol> <h3 id="procedure">Procedure</h3> <p>First, read the CIF. The <em>pymatgen</em> modules interpret this information and represent it as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pymatgen.core</span> <span class="kn">import</span> <span class="n">Structure</span>
<span class="n">struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">.</span><span class="nf">from_file</span><span class="p">(</span><span class="sh">'</span><span class="s">Downloads/9015662.cif</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Structure Summary
Lattice
    abc : 4.5937 4.5937 2.9587
 angles : 90.0 90.0 90.0
 volume : 62.434723178803
      A : 4.5937 0.0 2.8128300006215983e-16
      B : 7.387233015819564e-16 4.5937 2.8128300006215983e-16
      C : 0.0 0.0 2.9587
    pbc : True True True
PeriodicSite: Ti (0.0000, 0.0000, 0.0000) [0.0000, 0.0000, 0.0000]
PeriodicSite: Ti (2.2969, 2.2969, 1.4794) [0.5000, 0.5000, 0.5000]
PeriodicSite: O (1.4001, 1.4001, 0.0000) [0.3048, 0.3048, 0.0000]
PeriodicSite: O (3.1936, 3.1936, 0.0000) [0.6952, 0.6952, 0.0000]
PeriodicSite: O (3.6969, 0.8968, 1.4794) [0.8048, 0.1952, 0.5000]
PeriodicSite: O (0.8968, 3.6969, 1.4794) [0.1952, 0.8048, 0.5000]
</code></pre></div></div> <p>This demonstrates that the dimensions and arrangement of the crystal structure have been processed, as the Structure instance does not include every single Ti and O site in the unit cell. Instead, the remaining positions are represented using the PeriodicSite object. Furthermore, this shows that the lattice dimensions of the rutile structure from the COD differ slightly from the RRUFF entry.</p> <p>To calculate the diffraction pattern information, <em>pymatgen</em> provides the XRDCalculator module, which computes the positions and intensities (scaled according to the highest peak) for a given structure as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pymatgen.analysis.diffraction.xrd</span> <span class="kn">import</span> <span class="n">XRDCalculator</span>
<span class="n">calc</span> <span class="o">=</span> <span class="nc">XRDCalculator</span><span class="p">(</span><span class="n">wavelength</span><span class="o">=</span><span class="sh">"</span><span class="s">CuKa</span><span class="sh">"</span><span class="p">)</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="n">calc</span><span class="p">.</span><span class="nf">get_pattern</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">two_theta_range</span><span class="o">=</span><span class="p">(</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">))</span>
</code></pre></div></div> <p>The pattern object contains the discrete peak positions (<code class="language-plaintext highlighter-rouge">pattern.x</code>) and peak intensities (<code class="language-plaintext highlighter-rouge">pattern.y</code>).</p> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/xrd-sim-discrete-480.webp 480w, /assets/img/xrd-sim-discrete-800.webp 800w, /assets/img/xrd-sim-discrete-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/xrd-sim-discrete.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>A visual comparison between the simulated data and the measured XRD pattern validates that the peak positions align. However, notable disparities arise in the intensities: while the highest peak in the measured signal registers at approximately 800 arb. u., the simulated peaks are scaled relative to the highest peak at 100 arb. u. The measured intensities are influenced by various factors, such as instrument configuration and acquisition time. As a result, XRD patterns are commonly analyzed based on the relative intensities captured in the signal. A straightforward method to align the scales of measured and simulated intensities involves scaling based on the minimum and maximum values in each scan, known as Min-Max-Scaling.</p> <p>Furthermore, while the measured peaks exhibit broad shapes, the <em>XRDCalculator</em> module computes only discrete positions. Consequently, additional steps are necessary to modify the calculated diffraction peaks to match the broadened nature of the measured signal. This can be achieved by convolving the peaks with a kernel that approximates a probability distribution (centered at 0). In practice, peak shapes commonly display a Voigt profile. Alternatively, convolution with a Gaussian profile is also feasible and computationally less demanding.</p> <p>Prior to the convolution, it is essential to map the discrete peak positions onto a signal with a defined scanning range and equidistant measurement steps. The measured XRD pattern was obtained within a scanning range spanning from 5 to 90 degrees \(2θ\), with a step width of 0.01 degrees \(\Delta2θ\). Therefore, the calculated peaks are aligned with these measurement steps accordingly.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span> <span class="c1"># represent the simulated signal as a numpy vector
</span>
<span class="c1"># measurement steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mi">8501</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># initiliaze signal with all values equal to zero
</span><span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="n">angles</span><span class="p">,</span> <span class="n">intensities</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pattern</span><span class="p">.</span><span class="n">y</span>

<span class="c1"># iterate over the computed angles
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ang</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
    <span class="c1"># determine index of measured step for mapping
</span>    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmin</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">ang</span> <span class="o">-</span> <span class="n">steps</span><span class="p">))</span>
    <span class="c1"># place peak with corresponding intensity in signal
</span>    <span class="n">signal</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">intensities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="kn">from</span> <span class="n">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter1d</span>

<span class="n">signal</span> <span class="o">=</span> <span class="nf">gaussian_filter1d</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="sh">"</span><span class="s">constant</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/xrd-sim-convolved-480.webp 480w, /assets/img/xrd-sim-convolved-800.webp 800w, /assets/img/xrd-sim-convolved-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/xrd-sim-convolved.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>What is missing now? Mostly the noise and background intensities found in measured signals. In most Search/Match applications, background is modeled through Chebyshev polynomials and noise can be added through random sampling of values from a normal distribution (white noise). Both procedures are straightforward to accomplish in Python:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">coefs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span> <span class="c1"># coefficients for Chebyshev polynomial
</span><span class="n">chebyshev</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polynomial</span><span class="p">.</span><span class="n">chebyshev</span><span class="p">.</span><span class="nc">Chebyshev</span><span class="p">(</span><span class="n">ccoefs</span><span class="p">)</span>
<span class="c1"># evaluate the polynomial according to the measurement steps
</span><span class="n">background</span> <span class="o">=</span> <span class="n">chebyshev</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="n">steps</span><span class="p">.</span><span class="n">size</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># set seed for reproducability
</span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">default_rng</span><span class="p">(</span><span class="mi">2024</span><span class="p">)</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="nf">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.033</span><span class="p">,</span> <span class="n">steps</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>

<span class="c1"># add to signal, background not needed here
</span><span class="n">signal</span> <span class="o">+=</span> <span class="n">noise</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/xrd-sim-noise-480.webp 480w, /assets/img/xrd-sim-noise-800.webp 800w, /assets/img/xrd-sim-noise-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/xrd-sim-noise.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="python-powder-diffraction">Python-Powder-Diffraction</h2> <h3 id="exemplary-use">Exemplary Use</h3> <p>Instead of manually implementing the code described above, an artificial diffraction pattern can also be generated using the <a href="https://github.com/jschuetzke/python-powder-diffraction/"><em>python-powder-diffraction</em></a> package:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">powdiffrac</span> <span class="kn">import</span> <span class="n">Powder</span>
<span class="kn">from</span> <span class="n">powdiffrac.simulation</span> <span class="kn">import</span> <span class="n">generate_noise</span>
<span class="n">powder</span> <span class="o">=</span> <span class="n">Powder</span><span class="p">.</span><span class="nf">from_cif</span><span class="p">(</span><span class="sh">'</span><span class="s">Downloads/9015662.cif</span><span class="sh">'</span><span class="p">)</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">powder</span><span class="p">.</span><span class="nf">get_signal</span><span class="p">()</span>
<span class="n">signal</span> <span class="o">=</span> <span class="nf">generate_noise</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
</code></pre></div></div> <h3 id="pattern-variation">Pattern Variation</h3> <p>Although the generated XRD pattern looks visually similar to the measured signal, minor disparities persist. Firstly, there are slight deviations in peak positions attributable to a mismatch in lattice parameters. Secondly, certain simulated intensity peaks exceed the intensities observed in the measured data. Thirdly, disparities are evident in the shapes of peaks. Nonetheless, such deviations have to be expected in measured diffraction patterns.</p> <p>The <em>Powder</em> object furthermore includes functionality to generate varied signals. For example, the following code generates a pattern with varied peak positions, intensities, and shapes.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">powder</span> <span class="o">=</span> <span class="n">Powder</span><span class="p">.</span><span class="nf">from_cif</span><span class="p">(</span>
    <span class="sh">'</span><span class="s">Downloads/9015662.cif</span><span class="sh">'</span><span class="p">,</span>
    <span class="n">two_theta</span> <span class="o">=</span> <span class="p">(</span><span class="mf">5.</span><span class="p">,</span><span class="mf">90.</span><span class="p">),</span>
    <span class="n">max_strain</span> <span class="o">=</span> <span class="mf">0.04</span><span class="p">,</span> <span class="c1"># position variation
</span>    <span class="n">max_texture</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span> <span class="c1"># intensity variation
</span>    <span class="n">min_domain_size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="c1"># minimum grain size 10nm
</span>    <span class="n">max_domain_size</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="c1"># maximum grain size 100nm
</span>    <span class="n">peak_shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sh">"</span><span class="s">lorentzian</span><span class="sh">"</span><span class="p">,</span> <span class="c1"># desired peak shapes
</span>    <span class="n">vary_strain</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
    <span class="n">vary_texture</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
    <span class="n">vary_domain</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="mi">2024</span>
<span class="p">)</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">powder</span><span class="p">.</span><span class="nf">get_signal</span><span class="p">(</span><span class="n">vary</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">signal</span> <span class="o">=</span> <span class="nf">generate_noise</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/xrd-sim-varied-480.webp 480w, /assets/img/xrd-sim-varied-800.webp 800w, /assets/img/xrd-sim-varied-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/xrd-sim-varied.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure>]]></content><author><name></name></author><category term="guides"/><category term="python"/><category term="xrd"/><category term="simulation"/><summary type="html"><![CDATA[A quick guide to explain the python-powder-diffraction package]]></summary></entry></feed>